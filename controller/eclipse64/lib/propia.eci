:- module(propia).
:- export op(900, yfx, infers).
:- export infers / 2.
:- export tr_propia / 2.
:- export macro(myinfers / 5, tr_propia / 2, [goal, write]).
:- export macro(myinfers / 6, tr_propia / 2, [goal, write]).
:- tool(infers / 2, infers / 3).
:- comment(categories, ["Constraints", "Techniques"]).
:- comment(summary, "The Generalised Propagation Library").
:- comment(author, "Thierry Le Provost, ECRC and Mark Wallace, IC-Parc and ICL").
:- comment(copyright, "1995-2006 Cisco Systems, Inc").
:- comment(date, "$Date: 2009/04/17 07:08:03 $").
:- comment(infers / 2, [summary : "Do generalized propagation over Goal according to the approximation Language.", template : "+Goal infers +Language", desc : html("\tUsed to turn an arbitrary, nondeterministic Goal into a\n\t(deterministic) constraint, whose inference power is\n\tdetermined by the approximation Language. This is done using the\n\tGeneralised Propagation Method (see T. Le Provost and M. Wallace,\n\tDomain-Independent Propagation, Proceedings of the FGCS'92, Tokyo,\n\tJune 1992).\n\t<P>\n\tThe infers-predicate computes the most specific generalization\n\tof all the solutions of the Goal according to the approximation\n\tLanguage and delays if Goal has several non comparable solutions.\n\t<P>\n\tWith the language 'most', Goal is bound to the most specific\n\tgeneralization of all its solutions.  This generalisation will\n\tdepend what solvers are loaded - (e.g. ic, fd, sd or several of\n\tthem).  If one of the solutions is not a variant of this\n\tanswer, the goal is delayed until one of its variables is\n\tbound.  Note that the Goal may have an infinity of solutions.\n\t<P>\n\tUsing other languages, an approximation of this most specific\n\tgeneralization can be computed.  With the 'unique' language,\n\tinfers/2 instantiates the Goal only if it has a unique\n\tsolution (or the first solution of Goal subsumes all the\n\tothers).  With the 'consistent' language, infers/2 does not\n\tbind the Goal but only checks if Goal has at least one\n\tsolution.\n\t<P>\n\tThe name of a supported solver (ic, fd, ic_symbolic, sd, ...\n\tor a list of them) can also be used to specify the language.\n\tIn this case, the infers-predicate computes the most specific\n\tgeneralisation expressible in terms of that solver's domain\n\tvariables (e.g. intervals, finite domains, ...)\n\t<P>\n\tThe language 'ac' implements generalised arc consistency on\n\tthe table produced by computing all the (finitely) many\n\tsolutions to the goal in advance. This requires that some solver\n\timplementing the element/3 constraint is loaded (fd, ic_global).\n\t"), args : ["+Goal" : "Callable Term.", "+Language" : "One of the terms most, unique, consistent, ac, or the name of a supported solver (fd, ic, sd, ic_symbolic)"], resat : "No.", fail_if : "Fails if Goal has no solution.", exceptions : [4 : "Goal or Language is not instantiated.", 6 : "Language is not a correct language.", 68 : "Goal is an undefined procedure."], eg : "\n    Success:\n\t[eclipse]: member(X, [f(1), f(2)]) infers most.\n        X = f(_g1)\n        Delayed goals:\n        member(f(_g1), [f(1), f(2)]) infers most\n        yes.\n\t[eclipse]: [user].\n\tand(0, 0, 0).\n        and(0, 1, 0).\n\tand(1, 0, 0).\n\tand(1, 1, 1).\n\tuser       compiled traceable 528 bytes in 0.00 seconds\n\tyes.\n\t[eclipse]: and(0, X, Y).\n\tX = X\n\tY = 0     More? (;)          % Prolog: two solutions\n\tX = 0\n\tY = 0\n\tyes.\n\t[eclipse]: and(0, X, Y) infers most.\n\tX = X\n\tY = 0\n\tyes.                         % Prolog + infers: one solution\n\t[eclipse]: [user].\n\tgreater_than(succ(X), X).\n\tgreater_than(succ(X), Y) :- greater_than(X, Y).\n\tuser       compiled traceable 268 bytes in 0.00 seconds\n\tyes.\n\t[eclipse]: greater_than(X, zero).\n\tX = succ(zero)     More? (;) % Prolog: infinity of solutions\n\t...\n\t[eclipse]: greater_than(X, zero) infers most.\n\tX = succ(_g2)\n\tDelayed goals:\n\t    infers(greater_than(succ(_g2), zero), most, eclipse)\n\tyes.\n        [eclipse]: lib(fd).\n        ...\n        [eclipse]: member(X, [f(1), f(2)]) infers most.\n\tX = f(_g3[1, 2])\n\tyes.\n    Fail:\n\t[eclipse]: member(1, [2, 3]) infers consistent.\n\tno (more) solution.\n    Error:\n\tGoal infers most. % Error 4\n\ttrue infers true.  % Error 6\n    ", see_also : []]).
